//  PROJECT:     Android.MVC (A.MVC)
//  AUTHORS:     Adam Antinoo - adamantinoo.git@gmail.com
//  COPYRIGHT:   (c) 2013-2019 by Dimensinfin Industries, all rights reserved.
//  ENVIRONMENT: Android API16.
//  DESCRIPTION: Library that defines a generic Model View Controller core classes to be used
//               on Android projects. Defines the AndroidController factory and the AndroidController core methods to manage
//               a generic converter from a Graph Model to a hierarchical AndroidController model that finally will
//               be converted to a AndroidController list to be used on a BaseAdapter tied to a ListView.
package org.dimensinfin.android.mvc.datasource;

import android.content.Context;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ProgressBar;
import android.widget.TextView;
import org.dimensinfin.android.mvc.R;
import org.dimensinfin.android.mvc.controller.AAndroidController;
import org.dimensinfin.android.mvc.controller.RootController;
import org.dimensinfin.android.mvc.core.EEvents;
import org.dimensinfin.android.mvc.core.UIGlobalExecutor;
import org.dimensinfin.android.mvc.interfaces.IAndroidController;
import org.dimensinfin.android.mvc.interfaces.ICollaboration;
import org.dimensinfin.android.mvc.interfaces.IControllerFactory;
import org.dimensinfin.android.mvc.interfaces.IDataSource;
import org.dimensinfin.android.mvc.interfaces.IEventEmitter;
import org.dimensinfin.android.mvc.interfaces.IRender;
import org.dimensinfin.android.mvc.model.MVCRootNode;
import org.dimensinfin.android.mvc.model.Separator;
import org.dimensinfin.android.mvc.render.AbstractRender;
import org.dimensinfin.android.mvc.render.SeparatorRender;
import org.joda.time.Instant;
import org.joda.time.format.DateTimeFormatterBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * New complete core implementation for the DataSource that should be connected to the extended BaseAdapter to provide
 * the Adapter with the list of Controllers to be used for the rendering on the LisView.
 * @author Adam Antinoo
 */

// - CLASS IMPLEMENTATION
public abstract class AMVCDataSource implements IDataSource, IEventEmitter {
	protected static final Logger logger = LoggerFactory.getLogger(AMVCDataSource.class);
	private static final boolean isDebuggable = true;

	// - F I E L D - S E C T I O N
	/**
	 * Unique DataSource string identifier to locate this instance on the <code>DataSourceManager</code> in case the
	 * instances should be cached.
	 */
	private final DataSourceLocator locator;
	/** Copy of the extras bundle received by the Activity. */
	private Bundle extras = new Bundle();
	/**
	 * This is the Fragment or Activity code used to differentiate between different model generations. It is stored on
	 * the String format to be independent from any of the enumerated structures in the different modules. Anyway it
	 * should be a conversion from closed list of values.
	 */
	private String variant = "-DEFAULT-VARIANT-";
	/**
	 * Factory to be used on the AndroidController hierarchy generation. Each AndroidController has a connection to this
	 * factory to create its children parts from the model nodes. This is a mandatory field that should be available at
	 * the creation because the DS cannot work without a AndroidController Factory.
	 */
	private final IControllerFactory controllerFactory;
	/**
	 * Flag to indicate if the model contents generated can be cached and we can avoid running the <code>collaborate2Model
	 * ()</code> method on every fragment instantiation. If the model is suitable for caching we can speed up the turn of
	 * the device because we have not to generate again the DataSource and its model data structure.
	 */
	private boolean shouldBeCached = false;
	private int refreshTime = -1;
	/**
	 * This is the delegate to process inter node events. The data source will receive events from the controllers that
	 * are generated by this same data source and will also send events to all the connected listenrs that should be
	 * reported of controller changes.
	 *
	 * With that connections any change on the Model should be sent as an event to the Controller. Any action on the
	 * Controller will be also detected and sent along with model changes to the DataSource that will command the
	 * visualization changes by relaying the events to the DataSourceAdapter listener.
	 */
	private IEventEmitter eventController = new AbstractPropertyChanger();
	/**
	 * The initial node where to store the model. Model elements are children of this root. This version exports this node
	 * to dynamically detect the changes and generate the missing hierarchy elements that are being added during the Model
	 * generation. There are only a variant for the RootNode so we can lock it to a predefined instance. If we need to
	 * customize the Root nodes (for example to add special filtering) we should remove the
	 * <code>final</code> from this field.
	 */
	private final MVCRootNode dataModelRoot = new MVCRootNode();
	/**
	 * The root node for the AndroidController hierarchy that matches the data model hierarchy. YTHis is a special
	 * implementation of a AndroidController. Cannot be changed but has to define methods to customize its behavior to any
	 * need that suits the developer. For example sorting and filtering can me changed by adding policies to this
	 * instance.
	 */
	private RootController controllerRoot;
	/**
	 * The list of Parts to show on the viewer. This is the body section that is scrollable. This instance is shared
	 * during the <code>collaboration2View()</code> phase to use less memory and avoid copying references from list to
	 * list during the generation process.
	 */
	private final List<IAndroidController> dataSectionControllers = new ArrayList<>(100);
	/** Flag used to do not launch more update events when there is one pending. */
	private boolean _pending = false;

	// - C O N S T R U C T O R - S E C T I O N
	public AMVCDataSource(final DataSourceLocator locator, final IControllerFactory controllerFactory) {
		this.locator = locator;
		this.controllerFactory = controllerFactory;
		// Initialize other dependant fields.
		controllerRoot = new RootController(this.dataModelRoot, this.controllerFactory);
	}

	// - M E T H O D - S E C T I O N
//	private IDataSource getDataSource() {
//		return this;
//	}

	// - G E T T E R S   &   S E T T E R S
	public DataSourceLocator getDataSourceLocator() {
		return locator;
	}

	@Override
	public Bundle getExtras() {
		return extras;
	}

	@Override
	public String getVariant() {
		return variant;
	}

	@Override
	public IControllerFactory getControllerFactory() {
		return controllerFactory;
	}

//	public boolean isShouldBeCached() {
//		return shouldBeCached;
//	}

	public AMVCDataSource setExtras(final Bundle extras) {
		this.extras = extras;
		return this;
	}

	public AMVCDataSource setVariant(final String variant) {
		this.variant = variant;
		return this;
	}

	public AMVCDataSource shouldBeCached(final boolean shouldBeCached) {
		this.shouldBeCached = shouldBeCached;
		return this;
	}

	// - I D A T A S O U R C E   I N T E R F A C E
	public void cleanup() {
		dataModelRoot.clean();
		// Clear the listener event link from the discarded Parts.
		//		cleanLinks(dataSectionControllers);
		dataSectionControllers.clear();
		// And add back the initial spinner.
		dataSectionControllers.add(new OnLoadSpinnerController(new Separator(), this.controllerFactory));
	}

//	/**
//	 * This method checks if the DataSource is compatible with caching and if this is the case checks if there are
//	 * contents already cached so we can avoid to regenerate the model again. Use the counter of the children instead the
//	 * <code>isEmpty</code> because that function does not represent the content value for RootNodes. This is a reported
//	 * BUG.
//	 * @return
//	 */
//	public boolean isCached() {
//		return ((shouldBeCached) && (dataModelRoot.getChildren().isEmpty())) ? true : false;
//	}
//
	/**
	 * Get the current cache selected state. This is used internally to do some checks.
	 * @return
	 */
	public boolean isCacheable() {
		return shouldBeCached;
	}

	/**
	 * Sets the cacheable state for this DataSource. By default the cache state is <code>false</code> so no sources are
	 * caches. But in some cases the developer can speed up the model generation process and made it suitable for single
	 * initialization and caching. Use this setter to set the right state.
	 * @param cachestate new cache state for this data source. Affects at new source registrations with this same inique
	 *                   identifier.
	 * @return this same instance to allow functional programming.
	 */
	public IDataSource setCacheable(final boolean cachestate) {
		this.shouldBeCached = cachestate;
		return this;
	}

	public IDataSource setRefreshTime(final int time) {
		this.refreshTime = time;
		return this;
	}

	/**
	 * This is the single way to add more content to the DataSource internal model representation. Encapsulating this
	 * functionality on this method we make sure that the right events are generated and the model is properly updated and
	 * the render process will work as expected.
	 * Even this method should be compatible with nos dynamic Fragments. Anyway the launch for the update is done when the thread the generated this
	 * additions completes and at that time the data source should also fire a final update event that is the mandatory event used by
	 * non dynamic Fragments.
	 * @param newNode a new node to be added to the contents of the root point of the model.
	 * @return this IDataSource instance to allow functional coding.
	 */
	public IDataSource addModelContents(final ICollaboration newNode) {
		dataModelRoot.addChild(newNode);
		// Optimization - If the event is already launched and not processed do not launch it again.
		if (_pending) return this;
		else {
			// Fire the model structure change event. This processing is done on the background and on the UI thread.
			_pending = true;
			UIGlobalExecutor.submit(() -> {
				// Notify the Adapter that the Root node has been modified to regenerate the collaboration2View.
				this.propertyChange(new PropertyChangeEvent(this
						, EEvents.EVENTSTRUCTURE_NEWDATA.name(), newNode, dataModelRoot));
				_pending = false;
			});
			return this;
		}
	}

//	/**
//	 * Use the method variant to force the execution of the hierarchy update even in the case the process is already doing
//	 * that update.
//	 */
//	public IDataSource addModelContents(final ICollaboration newNode, final boolean forceEvent) {
//		dataModelRoot.addChild(newNode);
//		if (forceEvent)
//			AbstractPagerFragment._uiExecutor.submit(() -> {
//				// Notify the Adapter that the Root node has been modified to regenerate the collaboration2View.
//				propertyChange(new PropertyChangeEvent(this
//						, EEvents.EVENTSTRUCTURE_NEWDATA.name(), newNode, dataModelRoot));
//				_pending = false;
//			});
//		return this;
//	}

	public List<IAndroidController> getDataSectionContents() {
		return dataSectionControllers;
	}

//	/**
//	 * This method can be customized by developers to change the features implemented by the <code>IRootPart</code>. The
//	 * library provides an implementation but the code is open to make replacements at the key points to enhance
//	 * flexibility on the use of the library. This method is called whenever the root part container is still undefined
//	 * and calls any inherited implementation that defines a new instance for this nose. The internal creation method will
//	 * generate a <code>@link{RootAndroidPart}</code> instance that is suitable for most of developments.
//	 * @return a new instance of a <code>IRootPart</code> interface to be used as the root for the part hierarchy.
//	 */
//	public IRootPart createRootPart() {
//		return new RootController(dataModelRoot, controllerFactory);
//	}

//	public RootNode getRootModel() {
//		return this.dataModelRoot;
//	}

//	public IControllerFactory getFactory() {
//		return this.controllerFactory;
//	}
//

	/**
	 * Add an spinner at the first position on the AndroidController list to signal that we are doing some processing. If
	 * the datasource is cached it should not have any effect since the model is already generated and we should not have
	 * to wait for it.
	 */
	public void startOnLoadProcess() {
//		if (!isCached()) {
			dataSectionControllers.add(new OnLoadSpinnerController(new Separator(), this.controllerFactory));
//		}
	}

	/**
	 * After the model is created we have to transform it into the AndroidController list expected by the
	 * DataSourceAdapter. The AndroidController creation is performed by the corresponding ControllerFactory we got at the
	 * DataSource creation.
	 *
	 * We transform the model recursively and keeping the already available AndroidController instances if present. We create a
	 * duplicated of the resulting AndroidController model and we move already available parts from the current model to
	 * the new model or create new part and finally remove what is left and unused. This new implementation will use
	 * partial generation to split and speed up this phase.
	 *
	 * Next version will user sorted model instances so the search for already available controllers with be a sinple check on the
	 * first element queue.
	 */
	private void transformModel2Parts() {
		logger.info(">> [MVCDataSource.transformModel2Parts]");
		logger.info("-- [MVCDataSource.transformModel2Parts]> Initiating the refreshChildren() for the Model Root");
		// Intercept any exception on the creation of the model but do not cut the progress of the already added items.
		try {
			controllerRoot.refreshChildren();
		} catch (Exception ex) {
//			new ToastExceptionHandler(this.getAppContext());
//			if (isDebuggable) {
				// TODO Transform this into a toast or into a generic shutdown alert.
				ex.printStackTrace();
//			}
		}
		logger.info("<< [MVCDataSource.transformModel2Parts]> dataSectionControllers.size: {}", dataSectionControllers.size());
	}

	// - I E V E N T E M I T T E R   I N T E R F A C E
	public void addPropertyChangeListener(final PropertyChangeListener newListener) {
		this.eventController.addPropertyChangeListener(newListener);
	}

	public boolean sendChangeEvent(final String eventName) {
		this.eventController.firePropertyChange(new PropertyChangeEvent(this, eventName, null, null));
		return true;
	}

	// - P R O P E R T Y C H A N G E R   I N T E R F A C E

	/**
	 * This method is called whenever there is an event from any model change or any AndroidController interaction. There
	 * are two groups of events, <b>structural</b> that change the model structure and contents and that require a full
	 * regeneration of all the transformations and <b>content</b> that can change the list of elements to be visible at
	 * this point in time but that do not change the initial structure. The contents can happen from changes on the model
	 * data or by interactions on the Parts that have some graphical impact.
	 *
	 * If the model structure changes we should recreate the Model -> AndroidController transformation and generate
	 * another AndroidController tree with Parts matching the current model graph. At this transformation we can transform
	 * any data connected structure real or virtual to a hierarchy graph with the standard parent-child structure. We use
	 * the
	 * <code>collaborate2Model()</code> as a way to convert internal data structures to a hierarchy representation on a
	 * point in time. We isolate internal model ways to deal with data and we can optimize for the AndroidController
	 * hierarchy without compromising the model flexibility.
	 *
	 * If the contents change we only should run over the AndroidController tree to make the transformation to generate a
	 * new AndroidController list for all the new visible and render items. This is performed with the
	 * <code>collaborate2View()</code> method for any AndroidController that will then decide which of its internal
	 * children are going to be referenced for the collaborating list of Parts. This is the right place where to set up
	 * programmatic filtering or sorting because at this point we can influence the output representation for the model
	 * instance. We can also decorate the resulting AndroidController list breaking the one to one relationship between a
	 * model instance and a AndroidController instance.
	 *
	 * After the models changes we should send a message to the <code>DataSourceAdapter</code> to refresh the graphical
	 * elements and change the display. <code>DataSource</code> instances do not have a reference to the Adapter nor to
	 * the Fragment that created them but during the creation process the Adapter installed a listener to get a copy of
	 * the events sent by all its data sources. So we can sent that message by sending again another type of message
	 * related to the need for the display for update, the <code>EVENTADAPTER_REQUESTNOTIFYCHANGES</code>
	 * @param event the event to be processed. Event have a property name that is used as a selector.
	 */
	@Override
	public synchronized void propertyChange(final PropertyChangeEvent event) {
		logger.info(">> [MVCDataSource.propertyChange]> Processing Event: {}", event.getPropertyName());

		// - C O N T E N T   E V E N T S
		// The expand/collapse state has changed.
		if (EEvents.valueOf(event.getPropertyName()) ==
				EEvents.EVENTCONTENTS_ACTIONEXPANDCOLLAPSE) {
			synchronized (dataSectionControllers) {
				dataSectionControllers.clear();
				controllerRoot.collaborate2View(dataSectionControllers);
			}
		}

		// - S T R U C T U R E   E V E N T S
		if (EEvents.valueOf(event.getPropertyName()) ==
				EEvents.EVENTSTRUCTURE_NEWDATA) {
			this.transformModel2Parts();
			synchronized (dataSectionControllers) {
				dataSectionControllers.clear();
				controllerRoot.collaborate2View(dataSectionControllers);
			}
			// TODO - I think there is missing the action to update the listview. Trying with this messsage.
			this.sendChangeEvent(EEvents.EVENTADAPTER_REQUESTNOTIFYCHANGES.name());
		}
		if (EEvents.valueOf(event.getPropertyName()) ==
				EEvents.EVENTSTRUCTURE_DOWNLOADDATA) {
			this.transformModel2Parts();
			//			cleanLinks(dataSectionControllers);
			synchronized (dataSectionControllers) {
				dataSectionControllers.clear();
				controllerRoot.collaborate2View(dataSectionControllers);
			}
		}

		// - R E F R E S H   E V E N T S
		if (EEvents.valueOf(event.getPropertyName()) ==
				EEvents.EVENTSTRUCTURE_REFRESHDATA) {
			collaborate2Model();
			this.transformModel2Parts();
			//			cleanLinks(dataSectionControllers);
			synchronized (dataSectionControllers) {
				dataSectionControllers.clear();
				controllerRoot.collaborate2View(dataSectionControllers);
			}
		}

		// - A D A P T E R   E V E N T S
		// Send up the event to the DataSourceAdapter but be sure to run any display changes on the UI main thread.
		this.sendChangeEvent(EEvents.EVENTADAPTER_REQUESTNOTIFYCHANGES.name());
	}

//	protected void cleanLinks(final List<IAndroidAndroidController> partList) {
//		for (IAndroidController part : partList) {
//			if (part.getModel() instanceof AbstractPropertyChanger)
//				((AbstractPropertyChanger) part.getModel()).removePropertyChangeListener(part);
//		}
//		partList.clear();
//	}

	@Override
	public String toString() {
		return new StringBuilder("MVCDataSource [")
				.append("Identifier: ").append(getDataSourceLocator().getIdentity())
				.append("]")
				.toString();
	}


	public static class OnLoadSpinnerController extends AAndroidController<Separator> {
		// - C O N S T R U C T O R - S E C T I O N

		/**
		 * This constructor connect the root part to the DS and then top the other initialization elements that define the
		 * DS functionality but at a time that is not the creation time. Then the Factory and other data structures become
		 * available to the part hierarchy without affecting any other AndroidController implementation.
		 */
		public OnLoadSpinnerController(final Separator model, final IControllerFactory factory) {
			super(model, factory);
		}

		/**
		 * This method is required by the Adapter to get a unique identifier for each node to be render on a Viewer.
		 * @return a unique number identifier.
		 */
		@Override
		public long getModelId() {
			return Instant.now().getMillis();
		}

		@Override
		public IRender buildRender(final Context context) {
			return new SeparatorRender(this, context);
		}
	}

	public static class OnLoadSpinnerRender extends AbstractRender<Separator> {
		// - F I E L D - S E C T I O N
		private ProgressBar progress = null;
		private TextView progressCounter = null;

		private Instant _elapsedTimer = null;

		// - C O N S T R U C T O R - S E C T I O N
		public OnLoadSpinnerRender(final AAndroidController<Separator> controller, final Context context) {
			super(controller, context);
		}

		// - I R E N D E R   I N T E R F A C E
		@Override
		public void initializeViews() {
			progress = (ProgressBar) this.getView().findViewById(R.id.progress);
			progressCounter = (TextView) this.getView().findViewById(R.id.progressCounter);
			_elapsedTimer = Instant.now();
			new CountDownTimer(TimeUnit.DAYS.toMillis(1), TimeUnit.MILLISECONDS.toMillis(10)) {
				@Override
				public void onFinish() {
					progressCounter.setText(generateTimeString(_elapsedTimer.getMillis()));
					progressCounter.invalidate();
				}

				@Override
				public void onTick(final long millisUntilFinished) {
					progressCounter.setText(generateTimeString(_elapsedTimer.getMillis()));
					progressCounter.invalidate();
				}
			}.start();
		}

		@Override
		public void updateContent() {
			Animation rotation = AnimationUtils.loadAnimation(getContext(), R.anim.clockwise_rotation);
			rotation.setRepeatCount(Animation.INFINITE);
			progress.startAnimation(rotation);
		}

		@Override
		public int accessLayoutReference() {
			return R.layout.onload_spinner;
		}

		/**
		 * Displays an string in the format "nh nm ns" that is the number of seconds from the start point that is the value
		 * received as the parameter and the current instant on time.
		 */
		protected String generateTimeString(final long millis) {
			try {
				final long elapsed = Instant.now().getMillis() - millis;
				final DateTimeFormatterBuilder timeFormatter = new DateTimeFormatterBuilder();
				if (elapsed > TimeUnit.HOURS.toMillis(1)) {
					timeFormatter.appendHourOfDay(2).appendLiteral("h ");
				}
				if (elapsed > TimeUnit.MINUTES.toMillis(1)) {
					timeFormatter.appendMinuteOfHour(2).appendLiteral("m ").appendSecondOfMinute(2).appendLiteral("s");
				} else timeFormatter.appendSecondOfMinute(2).appendLiteral("s");
				return timeFormatter.toFormatter().print(new Instant(elapsed));
			} catch (final RuntimeException rtex) {
				return "0m 00s";
			}
		}

		// - B U I L D E R
//		public static class Builder extends AbstractRender.Builder<Separator> {
//			public Builder(final AAndroidController<Separator> controller, final Context context) {
//				super(controller, context);
//			}
//
//			public OnLoadSpinnerRender build() {
//				return new OnLoadSpinnerRender(this);
//			}
//		}
	}

//	// - B U I L D E R
//	public static class Builder {
//		// Mandatory
//		private DataSourceLocator locator;
//		private IControllerFactory controllerFactory;
//		// Optional
//		private String variant = "-DEFAULT-VARIANT-";
//		private Bundle extras = new Bundle();
//		private boolean shouldBeCached = false;
//		private int refreshTime = 1;
//
//		public Builder(final DataSourceLocator locator, final IControllerFactory controllerFactory) {
//			this.locator = locator;
//			this.controllerFactory = controllerFactory;
//		}
//
//		public Builder model(final DataSourceLocator locator) {
//			this.locator = locator;
//			return this;
//		}
//
//		public Builder controllerFactory(final IControllerFactory controllerFactory) {
//			this.controllerFactory = controllerFactory;
//			return this;
//		}
//
//		public Builder variant(final String variant) {
//			this.variant = variant;
//			return this;
//		}
//
//		public Builder extras(final Bundle extras) {
//			this.extras = extras;
//			return this;
//		}
//
//		public Builder shouldBeCached(final boolean shouldBeCached) {
//			this.shouldBeCached = shouldBeCached;
//			return this;
//		}
//
//		public Builder refreshTime(final int refreshTime) {
//			this.refreshTime = refreshTime;
//			return this;
//		}
//
//		public  MVCDataSource build(){
//			return new MVCDataSource(this) ;
//		}
//	}
}
